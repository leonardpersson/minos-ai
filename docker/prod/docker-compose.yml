version: '3.8'

# =====================================
# Production Docker Compose Configuration
# =====================================

networks:
  minos-prod:
    driver: bridge
    ipam:
      config:
        - subnet: 172.21.0.0/16
  frontend:
    driver: bridge
    external: true
  backend:
    driver: bridge
    internal: true

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/postgres
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/redis
  nginx_cache:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/nginx-cache
  app_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/logs
  ssl_certs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/ssl
  prometheus_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/prometheus
  grafana_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/grafana
  jaeger_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/minos/jaeger

services:
  # Production PostgreSQL with High Availability
  postgres-primary:
    image: postgres:16-alpine
    container_name: minos-postgres-primary
    hostname: postgres-primary
    restart: always
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_REPLICATION_USER: ${POSTGRES_REPLICATION_USER}
      POSTGRES_REPLICATION_PASSWORD: ${POSTGRES_REPLICATION_PASSWORD}
      PGDATA: /var/lib/postgresql/data/pgdata
      POSTGRES_MAX_CONNECTIONS: 500
      POSTGRES_SHARED_BUFFERS: 2GB
      POSTGRES_EFFECTIVE_CACHE_SIZE: 8GB
      POSTGRES_MAINTENANCE_WORK_MEM: 512MB
      POSTGRES_WORK_MEM: 16MB
      POSTGRES_WAL_BUFFERS: 64MB
      POSTGRES_CHECKPOINT_COMPLETION_TARGET: 0.9
      POSTGRES_RANDOM_PAGE_COST: 1.1
    ports:
      - "127.0.0.1:5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres-config/postgresql.conf:/etc/postgresql/postgresql.conf
      - ./postgres-config/pg_hba.conf:/etc/postgresql/pg_hba.conf
      - ./init-scripts:/docker-entrypoint-initdb.d
      - app_logs:/var/log/postgresql
    command: >
      postgres 
        -c config_file=/etc/postgresql/postgresql.conf
        -c hba_file=/etc/postgresql/pg_hba.conf
        -c logging_collector=on
        -c log_directory=/var/log/postgresql
        -c log_filename=postgresql-%Y-%m-%d_%H%M%S.log
        -c log_rotation_size=100MB
        -c log_rotation_age=1d
    networks:
      backend:
        ipv4_address: 172.21.1.2
    deploy:
      resources:
        limits:
          cpus: '4.0'
          memory: 8G
        reservations:
          cpus: '2.0'
          memory: 4G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        labels: "service=postgres-primary"

  # Redis with Persistence and High Availability
  redis-primary:
    image: redis:7-alpine
    container_name: minos-redis-primary
    hostname: redis-primary
    restart: always
    ports:
      - "127.0.0.1:6379:6379"
    volumes:
      - redis_data:/data
      - ./redis-config/redis.conf:/usr/local/etc/redis/redis.conf
      - app_logs:/var/log/redis
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      backend:
        ipv4_address: 172.21.1.3
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        labels: "service=redis-primary"

  # Nginx Load Balancer with SSL Termination
  nginx:
    image: nginx:alpine
    container_name: minos-nginx
    hostname: nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx-config/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx-config/conf.d:/etc/nginx/conf.d
      - ./nginx-config/ssl-params.conf:/etc/nginx/ssl-params.conf
      - ssl_certs:/etc/ssl/certs
      - nginx_cache:/var/cache/nginx
      - app_logs:/var/log/nginx
    environment:
      NGINX_WORKER_PROCESSES: auto
      NGINX_WORKER_CONNECTIONS: 2048
      NGINX_KEEPALIVE_TIMEOUT: 65
      NGINX_CLIENT_MAX_BODY_SIZE: 100M
    depends_on:
      - backend-1
      - backend-2
    networks:
      - frontend
      - minos-prod
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '1.0'
          memory: 1G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 20s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        labels: "service=nginx"

  # Backend Service Instance 1
  backend-1:
    build:
      context: ../../packages/backend
      dockerfile: ../../docker/prod/Dockerfile.backend
    container_name: minos-backend-1
    hostname: backend-1
    restart: always
    ports:
      - "127.0.0.1:3001:3000"
    volumes:
      - app_logs:/app/logs
      - ssl_certs:/app/ssl:ro
      - ./app-config:/app/config:ro
    environment:
      NODE_ENV: production
      PORT: 3000
      INSTANCE_ID: backend-1
      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-primary:5432/${POSTGRES_DB}
      REDIS_URL: redis://redis-primary:6379
      JWT_SECRET: ${JWT_SECRET}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      LOG_LEVEL: info
      MAX_WORKERS: 4
      RATE_LIMIT_WINDOW_MS: 60000
      RATE_LIMIT_MAX_REQUESTS: 100
      ENABLE_SWAGGER: false
      CORS_ORIGIN: ${CORS_ORIGIN}
      SSL_CERT_PATH: /app/ssl/cert.pem
      SSL_KEY_PATH: /app/ssl/key.pem
    depends_on:
      postgres-primary:
        condition: service_healthy
      redis-primary:
        condition: service_healthy
    networks:
      - minos-prod
      - backend
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"]
      interval: 20s
      timeout: 10s
      retries: 3
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "10"
        labels: "service=backend,instance=1"

  # Backend Service Instance 2
  backend-2:
    build:
      context: ../../packages/backend
      dockerfile: ../../docker/prod/Dockerfile.backend
    container_name: minos-backend-2
    hostname: backend-2
    restart: always
    ports:
      - "127.0.0.1:3002:3000"
    volumes:
      - app_logs:/app/logs
      - ssl_certs:/app/ssl:ro
      - ./app-config:/app/config:ro
    environment:
      NODE_ENV: production
      PORT: 3000
      INSTANCE_ID: backend-2
      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-primary:5432/${POSTGRES_DB}
      REDIS_URL: redis://redis-primary:6379
      JWT_SECRET: ${JWT_SECRET}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      LOG_LEVEL: info
      MAX_WORKERS: 4
      RATE_LIMIT_WINDOW_MS: 60000
      RATE_LIMIT_MAX_REQUESTS: 100
      ENABLE_SWAGGER: false
      CORS_ORIGIN: ${CORS_ORIGIN}
      SSL_CERT_PATH: /app/ssl/cert.pem
      SSL_KEY_PATH: /app/ssl/key.pem
    depends_on:
      postgres-primary:
        condition: service_healthy
      redis-primary:
        condition: service_healthy
    networks:
      - minos-prod
      - backend
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"]
      interval: 20s
      timeout: 10s
      retries: 3
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "10"
        labels: "service=backend,instance=2"

  # Indexer Service Instance 1
  indexer-1:
    build:
      context: ../../packages/indexer
      dockerfile: ../../docker/prod/Dockerfile.indexer
    container_name: minos-indexer-1
    hostname: indexer-1
    restart: always
    ports:
      - "127.0.0.1:3011:3001"
    volumes:
      - app_logs:/app/logs
      - ./indexer-config:/app/config:ro
    environment:
      NODE_ENV: production
      PORT: 3001
      INSTANCE_ID: indexer-1
      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-primary:5432/${POSTGRES_DB}
      REDIS_URL: redis://redis-primary:6379
      SOLANA_RPC_URL: ${SOLANA_RPC_URL}
      SOLANA_WS_URL: ${SOLANA_WS_URL}
      LOG_LEVEL: info
      INDEXER_BATCH_SIZE: 50
      INDEXER_INTERVAL_MS: 100
      INDEXER_CONCURRENT_PROCESSORS: 10
      ENABLE_METRICS: true
      PROMETHEUS_PORT: 9090
    depends_on:
      postgres-primary:
        condition: service_healthy
      redis-primary:
        condition: service_healthy
    networks:
      - minos-prod
      - backend
    deploy:
      resources:
        limits:
          cpus: '4.0'
          memory: 8G
        reservations:
          cpus: '2.0'
          memory: 4G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3001/health || exit 1"]
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 60s
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "10"
        labels: "service=indexer,instance=1"

  # AI Models Service
  ai-models:
    build:
      context: ../../packages/ai-models
      dockerfile: ../../docker/prod/Dockerfile.ai-models
    container_name: minos-ai-models
    hostname: ai-models
    restart: always
    ports:
      - "127.0.0.1:8001:8000"
    volumes:
      - app_logs:/app/logs
      - ./ai-models/data:/app/data:ro
      - ./ai-models/models:/app/models:ro
    environment:
      PYTHONPATH: /app
      ENVIRONMENT: production
      LOG_LEVEL: info
      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-primary:5432/${POSTGRES_DB}
      REDIS_URL: redis://redis-primary:6379
      MODEL_CACHE_DIR: /app/.cache
      MAX_WORKERS: 4
      WORKER_TIMEOUT: 300
    depends_on:
      postgres-primary:
        condition: service_healthy
      redis-primary:
        condition: service_healthy
    networks:
      - minos-prod
      - backend
    deploy:
      resources:
        limits:
          cpus: '8.0'
          memory: 16G
        reservations:
          cpus: '4.0'
          memory: 8G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
      interval: 60s
      timeout: 30s
      retries: 3
      start_period: 120s
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "10"
        labels: "service=ai-models"

  # Prometheus Monitoring
  prometheus:
    image: prom/prometheus:latest
    container_name: minos-prometheus
    hostname: prometheus
    restart: always
    ports:
      - "127.0.0.1:9090:9090"
    volumes:
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - ./monitoring/prometheus/rules:/etc/prometheus/rules
      - prometheus_data:/prometheus
      - app_logs:/var/log/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=90d'
      - '--storage.tsdb.retention.size=50GB'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--web.enable-lifecycle'
      - '--web.enable-admin-api'
      - '--log.level=info'
    networks:
      - minos-prod
      - backend
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "promtool query instant 'up{job=\"prometheus\"}' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        labels: "service=prometheus"

  # Grafana Visualization
  grafana:
    image: grafana/grafana:latest
    container_name: minos-grafana
    hostname: grafana
    restart: always
    ports:
      - "127.0.0.1:3003:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards
      - app_logs:/var/log/grafana
    environment:
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD}
      GF_SECURITY_SECRET_KEY: ${GRAFANA_SECRET_KEY}
      GF_USERS_ALLOW_SIGN_UP: false
      GF_USERS_ALLOW_ORG_CREATE: false
      GF_LOG_LEVEL: info
      GF_SERVER_PROTOCOL: https
      GF_SERVER_CERT_FILE: /etc/ssl/certs/grafana.crt
      GF_SERVER_CERT_KEY: /etc/ssl/certs/grafana.key
      GF_DATABASE_TYPE: postgres
      GF_DATABASE_HOST: postgres-primary:5432
      GF_DATABASE_NAME: ${POSTGRES_DB}_grafana
      GF_DATABASE_USER: ${POSTGRES_USER}
      GF_DATABASE_PASSWORD: ${POSTGRES_PASSWORD}
      GF_SESSION_PROVIDER: redis
      GF_SESSION_PROVIDER_CONFIG: addr=redis-primary:6379,pool_size=100
    depends_on:
      prometheus:
        condition: service_healthy
      postgres-primary:
        condition: service_healthy
      redis-primary:
        condition: service_healthy
    networks:
      - minos-prod
      - backend
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f https://localhost:3000/api/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        labels: "service=grafana"

  # Jaeger Distributed Tracing
  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: minos-jaeger
    hostname: jaeger
    restart: always
    ports:
      - "127.0.0.1:16686:16686"
      - "127.0.0.1:14268:14268"
    volumes:
      - jaeger_data:/badger
      - app_logs:/var/log/jaeger
    environment:
      COLLECTOR_OTLP_ENABLED: true
      SPAN_STORAGE_TYPE: badger
      BADGER_EPHEMERAL: false
      BADGER_DIRECTORY_VALUE: /badger/data
      BADGER_DIRECTORY_KEY: /badger/key
      BADGER_TTL: 72h0m0s
      BADGER_PATH: /badger
    networks:
      - minos-prod
      - backend
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:14269/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        labels: "service=jaeger"

  # Elasticsearch for Log Aggregation
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: minos-elasticsearch
    hostname: elasticsearch
    restart: always
    ports:
      - "127.0.0.1:9200:9200"
    volumes:
      - ./elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml
      - ./elasticsearch/data:/usr/share/elasticsearch/data
      - app_logs:/var/log/elasticsearch
    environment:
      discovery.type: single-node
      ES_JAVA_OPTS: "-Xms2g -Xmx2g"
      bootstrap.memory_lock: true
      xpack.security.enabled: true
      xpack.security.authc.api_key.enabled: true
      ELASTIC_PASSWORD: ${ELASTIC_PASSWORD}
    ulimits:
      memlock:
        soft: -1
        hard: -1
    networks:
      - backend
    deploy:
      resources:
        limits:
          cpus: '4.0'
          memory: 4G
        reservations:
          cpus: '2.0'
          memory: 2G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        labels: "service=elasticsearch"

  # Logstash for Log Processing
  logstash:
    image: docker.elastic.co/logstash/logstash:8.11.0
    container_name: minos-logstash
    hostname: logstash
    restart: always
    ports:
      - "127.0.0.1:5044:5044"
    volumes:
      - ./logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml
      - ./logstash/pipeline:/usr/share/logstash/pipeline
      - app_logs:/var/log/logstash
    environment:
      LS_JAVA_OPTS: "-Xms1g -Xmx1g"
      ELASTICSEARCH_HOST: elasticsearch:9200
      ELASTIC_PASSWORD: ${ELASTIC_PASSWORD}
    depends_on:
      elasticsearch:
        condition: service_healthy
    networks:
      - backend
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '1.0'
          memory: 1G
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9600/_node/stats || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
        labels: "service=logstash"

  # Backup Service
  backup:
    image: postgres:16-alpine
    container_name: minos-backup
    hostname: backup
    restart: "no"
    volumes:
      - ./backups:/backups
      - ./backup-scripts:/scripts
      - app_logs:/var/log/backup
    environment:
      PGPASSWORD: ${POSTGRES_PASSWORD}
      BACKUP_RETENTION_DAYS: 30
      BACKUP_S3_BUCKET: ${BACKUP_S3_BUCKET}
      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
    depends_on:
      - postgres-primary
    networks:
      - backend
    command: /scripts/backup.sh
    profiles:
      - backup
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=backup"